# Describing Ansible

When working with servers, one of the principles is to keep a minimal footprint of applications. Many automation tools use local agents installed on servers; Ansible is agentless and uses a push model, no extra software is running when Ansible is not in use. 

It has been kept as minimalist as possible, requiring only OpenSSH and Python to operate and using the credentials of the user. It uses su or sudo when privilege escalation is required. Ideally, password-less logins are used, using SSH credentials. 

Remote machines are all independent of each other. 

One advantage of this simple model is that we could also use Ansible to deploy software or updates. We can also use it to deploy or provision servers in a virtual environment. In datacentre slang this is sometimes called standing up a server. 
Sometimes things need to happen in sequence, this is referred to as orchestration. For example, on large-scale application, we bring up the database servers first, then the business logic layer, then the presentation layer, then the load balancing and security. 

Ansible can also be used for deployments. I can take software, generate executable files, move these files to a production server and start any required services. 

Ansible is idempotent; that is, if you run it multiple times, you get the same result. Ansible sets the state of a server but checks first to see if an action needs to be taken. 

Ansible uses modules, this defines what Ansible has pre-programmed capabilities for and they are OS specific. It is worthwhile looking through the list of available modules. Modules are declarative, you describe the state you want a server to be in, not how to get to that state. For example, the YUM module gives a simple example for doing updates.

```
name: upgrade all packages
 yum: name=* state=latest
```
Ansible can also use dynamic scripts to pull information from another system such as Amazon.

# Playbooks
Ansible uses YAML as its back-end data source and Jinja2 for templating. It refers to its documents with collections of tasks as playbooks. Ansible uses an inventory file to describe all the nodes which can be configured by Ansible; /etc/ansible/inventory. 

The tasks are run in the order specified in a playbook against all these hosts in parallel, and Ansible waits until all hosts have completed a task before moving to the next task. 

As example, this is a simple Playbook to install Apache.

```
---
- name: This sets up an httpd webserver
  hosts: www.local
  tasks:
  - name: Install the httpd rpm
    yum: name=httpd
  - name: start the httpd service
    service: name=httpd state=started
  - name: Open port 80
    firewalld: service=http permanent=true state=enabled
  - name: start the firewalld service
    service: name=firewalld state=restarted
```

Go [here](http://docs.ansible.com) and begin to have a look around at the Ansible docs.

# Gathering Facts
Before Ansible starts any serious configuration, it gathers facts. This is the process of querying the target host and extracting any relevant information for its configuration. If you find a CentOS server, you might use yum for configuration, if it’s a Debian-based distro, you will use apt.

- CPU architecture
- Operating system
- Version
- Memory architecture
- Disc architecture 

Ansible uses a module called set up to do this, you can call this module from the command line to see what Ansible sees. In terms of Python, the return structure is a dictionary. Interestingly, you can leave a facts file on any host, and access and utilise the content.  