{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Introduction to Ansible</p> <p>There is a classic Sci-Fi book by Orson Scott Card called Ender\u2019s Game (the movie was less good but did have Harrison Ford!). In the book the Ansible is used to control many remote spaceships at the same time. Setting up infrastructure is a long and complex job. The configuration tool Ansible is one of the ways we can configure many nodes simultaneously using automation, in an agentless manner; that is without installing dedicated software on the target hardware. Ansible is maintained on GitHub and the design principles include \u201c\u2026have a dead simple setup process and a minimal learning curve\u201d. One of the better books on the subject is by O\u2019Reilly; Hochstein, L. and Moser, R., 2017. Ansible: Up and Running: Automating Configuration Management and Deployment the Easy Way. \" O'Reilly Media, Inc.\".</p> <p>Before beginning you would normally be familiar with the environment you are trying to configure. I would prefer to be familiar with network equipment or an operating system before using Ansible to configure it. If I can\u2019t configure and script the environment, I have work to do before attempting to automate its configuration. </p> <p>Ideally configuration should be stateless. I should be able to say a server has a particular configuration and then (in the words of Jean-Luc Picard) \u201cmake it so\u201d. </p> <p>If a service is already installed it should not be duplicated no matter how many times I run the configuration tool. And I should be able to run tasks in parallel across multiple servers. </p> <p>The descriptions in this document are very simple and as you can imagine, a real-world deployment will have some complexity and formality. The main thing I needed to leave out for simplicity was version control. In real deployments, will keep a track of changes to any configuration files and these days, I use git exclusively for this. </p> <p>Our starting point: we need a domain specific language (DSL) to describe the state of servers or devices and we will need tools and a protocol to enforce this state.</p>"},{"location":"1.%20Background/1/","title":"Describing Ansible","text":"<p>When working with servers, one of the principles is to keep a minimal footprint of applications. Many automation tools use local agents installed on servers; Ansible is agentless and uses a push model, no extra software is running when Ansible is not in use. </p> <p>It has been kept as minimalist as possible, requiring only OpenSSH and Python to operate and using the credentials of the user. It uses su or sudo when privilege escalation is required. Ideally, password-less logins are used, using SSH credentials. </p> <p>Remote machines are all independent of each other. </p> <p>One advantage of this simple model is that we could also use Ansible to deploy software or updates. We can also use it to deploy or provision servers in a virtual environment. In datacentre slang this is sometimes called standing up a server.  Sometimes things need to happen in sequence, this is referred to as orchestration. For example, on large-scale application, we bring up the database servers first, then the business logic layer, then the presentation layer, then the load balancing and security. </p> <p>Ansible can also be used for deployments. I can take software, generate executable files, move these files to a production server and start any required services. </p> <p>Ansible is idempotent; that is, if you run it multiple times, you get the same result. Ansible sets the state of a server but checks first to see if an action needs to be taken. </p> <p>Ansible uses modules, this defines what Ansible has pre-programmed capabilities for and they are OS specific. It is worthwhile looking through the list of available modules. Modules are declarative, you describe the state you want a server to be in, not how to get to that state. For example, the YUM module gives a simple example for doing updates.</p> <p><pre><code>name: upgrade all packages\n yum: name=* state=latest\n</code></pre> Ansible can also use dynamic scripts to pull information from another system such as Amazon.</p>"},{"location":"1.%20Background/1/#playbooks","title":"Playbooks","text":"<p>Ansible uses YAML as its back-end data source and Jinja2 for templating. It refers to its documents with collections of tasks as playbooks. Ansible uses an inventory file to describe all the nodes which can be configured by Ansible; /etc/ansible/inventory. </p> <p>The tasks are run in the order specified in a playbook against all these hosts in parallel, and Ansible waits until all hosts have completed a task before moving to the next task. </p> <p>As example, this is a simple Playbook to install Apache.</p> <pre><code>---\n- name: This sets up an httpd webserver\n  hosts: www.local\n  tasks:\n  - name: Install the httpd rpm\n    yum: name=httpd\n  - name: start the httpd service\n    service: name=httpd state=started\n  - name: Open port 80\n    firewalld: service=http permanent=true state=enabled\n  - name: start the firewalld service\n    service: name=firewalld state=restarted\n</code></pre> <p>Go here and begin to have a look around at the Ansible docs.</p>"},{"location":"1.%20Background/1/#gathering-facts","title":"Gathering Facts","text":"<p>Before Ansible starts any serious configuration, it gathers facts. This is the process of querying the target host and extracting any relevant information for its configuration. If you find a CentOS server, you might use yum for configuration, if it\u2019s a Debian-based distro, you will use apt.</p> <ul> <li>CPU architecture</li> <li>Operating system</li> <li>Version</li> <li>Memory architecture</li> <li>Disc architecture </li> </ul> <p>Ansible uses a module called set up to do this, you can call this module from the command line to see what Ansible sees. In terms of Python, the return structure is a dictionary. Interestingly, you can leave a facts file on any host, and access and utilise the content. \u2003</p>"},{"location":"1.%20Background/2/","title":"The hosts file","text":"<p>Ansible uses its own hosts file to define which machines it will operate on; it is an inventory of all the target servers. Although servers can be defined undifferentiated, it is normal to group them under functional headings. I could define groups as shown below.</p> <p>I can deal with Ubuntu and CentOS tasks separately, and then also deal with all Apache servers regardless of their base OS.</p> <p>As you can imagine, the configuration of a real Apache server can be really complicated. Consider that all Web servers these days support HTTPS. When you are standing up a Web Server the chances are, you\u2019re also going to have to copy across keys and certificates and configure them!</p> <pre><code>[UB1804]\nUB1.example.com\nUB2.example.com \n\n[CO7]\nCO7-1.example.com\nCO7-2.example.com \n\n[Apache]\nUB1.example.com\nCO7-2.example.com \n</code></pre> <p>You can also define groups of groups. In the example above, to address all my learning servers</p> <pre><code>[AllLinux]\nCO7\nUB1804\n</code></pre>"},{"location":"1.%20Background/2/#dynamic-inventory","title":"Dynamic Inventory","text":"<p>Once we get to large-scale cloud environments, static configuration files are no longer adequate to tracker infrastructure. Suppose I have a flexible deployment where I provision services as required in AWS. In this case, my inventory will be dynamic in nature, new server instances will spin up and spin down as required. </p> <p>Ansible handles this by allowing an inventory file to be executable under-Python. If Ansible sees an executable file, it assumes that it should be run and that it will return a JSON object with the inventory data.</p> <p>At the other end of all this is a cloud service provider like AWS, which provides an API containing this inventory information.</p>"},{"location":"1.%20Background/2/#configuration-files","title":"Configuration Files","text":"<p>We can have a section in the playbooks with any variables required to keep things tidy.</p> <p><pre><code>vars:\n  secret_key: /users/johnoraw/.ssh/secret.rsa\n</code></pre> Playbooks can be long and complex, as can the inventory file. For this reason, we may have separate configuration files to hold things like defaults and security key information. We can then declare this grouped variable information file in the playbook.</p> <p><pre><code>vars_files:\n  jor_keys.yml\n</code></pre> When host configuration information gets too complex, we can dedicate an individual file to a host and save it in the directory host_vars.  When group configuration information gets too complex, we can dedicate an individual file to the group and save it in the directory group_vars.</p>"},{"location":"2.%20Test%20Environment/1/","title":"Servers","text":"<p>These exercises will work in any environment where you can run safely run multiple Linux instances. I assume you can you Linux and VMWare Workstation.</p> <p>I will be doing these exercises in VMWare Workstation on a local computer. My NAT'd network uses 192.168.228.0/24</p> <p>I do updates on my gold images and then create the following VMs as linked clones.</p> Type hostname Server AnsibleServer1 Server AnsibleServer2 <p>I need to assign the following IP addresses to my nodes.</p> hostname IPv4 address AnsibleServer1 192.168.228.111 AnsibleServer2 192.168.228.112 <p>The gateway for this LAN is on 192.168.228.2 and I use 9.9.9.9 as an Internet DNS. </p>"},{"location":"2.%20Test%20Environment/1/#static-ip-address","title":"Static IP address","text":"<p>Set static IP addreses on each server. Check to see what configuration file exists at /etc/netplan</p> <p>For me, this was 50-cloud-init.yaml, examine this file, it is set for DHCP.</p> <p>I make a backup before I begin.  <pre><code>sudo cp 50-cloud-init.yaml 50-cloud-init.bak\n</code></pre> Next I edit the content as shown below, the example is for ansibleserver1.</p> <pre><code>network:\n  ethernets:\n    ens33:\n      dhcp4: no\n      addresses:\n        - 192.168.228.111/24\n      routes:\n        - to: default\n          via: 192.168.228.2\n      nameservers:\n        addresses:\n          - 9.9.9.9\n  version: 2\n</code></pre> <p>Do some reading to understand cloud.init, we need to disable it!</p> <p>Create a file  /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the content as shown below. <pre><code>network: {config: disabled}\n</code></pre></p>"},{"location":"2.%20Test%20Environment/1/#hostname","title":"Hostname","text":"<p>I edit /etc/hostname to give each server the correct hostname.</p>"},{"location":"2.%20Test%20Environment/1/#host-resolution","title":"Host resolution","text":"<p>I edit /etc/hosts as we do not have a local DNS (and we must be able to find the other nodes!). </p> <p><pre><code>127.0.0.1 localhost\n192.168.228.110 ansiblemanager\n192.168.228.111 ansibleserver1\n192.168.228.112 ansibleserver2\n192.168.228.113 ansibleserver3\n\n# The following lines are desirable for IPv6 capable hosts\n::1     ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n</code></pre> Adapt these configurations and also configure ansibleserver2</p>"},{"location":"2.%20Test%20Environment/2/","title":"Desktop","text":"<p>I do updates on my gold images and then create the following VM as a linked clone.</p> Type hostname Desktop AnsibleManager <p>I need to assign the following IP address to my node.</p> hostname IPv4 address AnsibleManager 192.168.228.110 <p>The gateway for this LAN is on 192.168.228.2 and I use 9.9.9.9 as an Internet DNS. </p> Fig 1. Desktop Network settings."},{"location":"2.%20Test%20Environment/2/#hostname","title":"Hostname","text":"<p>I edit /etc/hostname to give the desktop the correct hostname.</p>"},{"location":"2.%20Test%20Environment/2/#host-resolution","title":"Host resolution","text":"<p>I edit /etc/hosts as we do not have a local DNS (and we must be able to find the other nodes!). </p> <pre><code>127.0.0.1 localhost\n192.168.228.110 ansiblemanager\n192.168.228.111 ansibleserver1\n192.168.228.112 ansibleserver2\n192.168.228.113 ansibleserver3\n\n# The following lines are desirable for IPv6 capable hosts\n::1     ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n</code></pre> <p>Test the VMs by attempting an update and then ping from VM to VM using their hostnames.</p>"},{"location":"3.%20Security/1/","title":"Assumptions","text":"<p>I am going to do this as simply as possible, as you may not have covered cryptography yet!</p> <p>I have carried out all the tasks in this walkthrough using my personal account. This is bad practice. On a production system, I would create a service account called provisioning and use this for all tasks associated with Ansible, at both the client and server.</p> <p>To make it work seamlessly, the provisioning account must be able to sudo without a password. I cover how to configure this in my Linux SSH notes. I am also using RSA keys, it would be better to use EC or ED, more on this in my security and Linux notes. </p>"},{"location":"3.%20Security/1/#ansiblemanager","title":"AnsibleManager","text":"<p>I need to install ssh server, if not already installed. <pre><code>sudo apt install openssh-server -y\n</code></pre> Next I need to generate some local keys for use with Ansible. <pre><code>ssh-keygen -t rsa -b 4096 -f ~/.ssh/local.rsa -C john.oraw@hotmail.com\n</code></pre> I need to copy the SSH IS from my AnsibleManager to each server. <pre><code>ssh-copy-id -i ~/.ssh/local.rsa.pub johnoraw@ansibleserver1\n</code></pre> and <pre><code>ssh-copy-id -i ~/.ssh/local.rsa.pub johnoraw@ansibleserver2\n</code></pre> Now to save you some time...to get the SSH agent to load into an SSH session requires some extra steps. To bypass this, we should only work from the colsole in the desktop. To test, try to login to both ansibleservers from the desktop only. You will not be asked for a password!</p>"},{"location":"4.%20Ansible%20Manager/1/","title":"Installation","text":"<p>On ansiblemanager, I need to install Ansible. I add Ansible's PPA to the list of sources and update them. <pre><code>sudo apt-add-repository ppa:ansible/ansible\nsudo apt update\n</code></pre> And then install the package. <pre><code>sudo apt install ansible -y\n</code></pre></p> <p>I edit Ansible's inventory file /etc/ansible/hosts and document all hosts with appropriate group names.  Hosts can be members of multiple groups.</p> Fig 2. Ansible Hosts. <p>I can test the host file by typing <pre><code>ansible-inventory --list -y\n</code></pre></p> Fig 3. List Hosts. <p>Now test you can access both servers. I must do this from a terminal window in ansiblemanager <pre><code>ansible all -m ping -u johnoraw\n</code></pre></p> Fig 4. List Hosts. <p>I can now run arbitrary commands on any group of servers. The df command reports on file system disk space usage. <pre><code>ansible all -a \"df -h\" -u johnoraw\n</code></pre></p> Fig 5. Disk analysis"},{"location":"4.%20Ansible%20Manager/2/","title":"Playbooks","text":"<p>Playbooks are written as YAML files, you need to be careful of the spacing, indentation, etc. I save mine under the ~/Ansible directory. Getting privilege escalation is an issue and you will need to do research on any real application to see what is appropriate.</p>"},{"location":"4.%20Ansible%20Manager/2/#updates","title":"Updates","text":"<p>I'm going to install updates on all my web servers.  This playbook is an example from jeffgerling.com</p> <p><pre><code>---\n- name: Updates\n  hosts: all\n  gather_facts: yes\n  become: yes\n\n  tasks:\n    - name: Perform a dist-upgrade.\n      ansible.builtin.apt:\n        upgrade: dist\n        update_cache: yes\n\n    - name: Check if a reboot is required.\n      ansible.builtin.stat:\n        path: /var/run/reboot-required\n        get_checksum: no\n      register: reboot_required_file\n\n    - name: Reboot the server (if required).\n      ansible.builtin.reboot:\n      when: reboot_required_file.stat.exists == true\n\n    - name: Remove dependencies that are no longer required.\n      ansible.builtin.apt:\n        autoremove: yes\n</code></pre> I need to (become root) provide the sudo password for the target servers, my full command line is</p> <pre><code>ansible-playbook updates.yml --ask-become-pass\n</code></pre> Fig 6. Run updates."},{"location":"4.%20Ansible%20Manager/2/#webservers","title":"Webservers","text":"<p>I want to install Apache on my web servers only. I use the following playbook. <pre><code>- name: Install Apache\n  hosts: webservers\n  become: true\n\n  tasks:\n  - name: Install Apache\n    apt:\n      name: apache2\n      state: present\n\n  - name: Start Apache\n    service:\n      name: apache2\n      state: started\n      enabled: yes\n</code></pre> I ran the command <pre><code>ansible-playbook InstallApache.yml --ask-become-pass\n</code></pre> WHich gave me the result</p> Fig 7. Install Apache. <p>I go to a web browser to check if the service is running.</p> Fig 8. Apache test."},{"location":"4.%20Ansible%20Manager/2/#databases","title":"Databases","text":"<p>Finally, we need to install MariaDB on all our database servers. <pre><code>- name: Install MariaDB\n  hosts: mariadbservers\n  become: true\n\n  tasks:\n  - name: Install MariaDB\n    apt:\n      name: mariadb-server\n      state: present\n\n  - name: Start MariaDB\n    service:\n      name: mariadb\n      state: started\n      enabled: yes\n</code></pre></p> <p>I execute the playbook with  <pre><code>ansible-playbook InstallMariaDB.yml --ask-become-pass\n</code></pre></p> <p>And I get the result</p> Fig 9. MariaDB install. <p>And as always I test. From the SSH console of ansibleserver2</p> Fig 10. MariaDB test. <p>Tested!</p>"}]}